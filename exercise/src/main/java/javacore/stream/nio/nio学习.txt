缓冲区都具有:
*一个容量,它永远不能改变;
*一个读写位置,下一个值将在此进行读写;
*一个界限,超过它进行读写是没有意义的;
*一个可选的标记,用于重复一个读入或写出操作
使用缓存区的主要目的是执行"写,然后读入"循环.假设一个缓冲区;在一开始,位置为0,界限等于容量.不断调用put将值添加到这个缓冲区中,
当我们耗尽所有的数据或者写出的数据量达到容量大小时,就该切换到读入操作了. 此时调用flip方法将界限设置到当前位置,并把位置复位到0.
现在在remaining方法返回正数时,不断调用get方法.在我们讲缓冲区中所有的值都读入之后,调用clear使缓冲区为下一次写循环做好准备.
clear方法将位置复位到0,并将界限复位到容量.如果想重新读入缓冲区,可以使用rewind或mark/reset方法.

文件加锁机制
文件加锁机制是依赖于操作系统的,所以需要注意一下几点:
*在某些系统中,文件加锁仅仅是建议性的,如果一个应用未能得到锁,仍旧可以向被另外一个应用并发锁定的文件执行写操作
*在某些系统中,不能在锁定一个文件的同时将其映射到内存中
*文件锁是由整个java虚拟机持有的.如果有两个程序是由同一个虚拟机启动的,那么他们不可能每一个都获得一个在同一个文件上的锁,当调用lock
和tryLock方法时,如果虚拟机已经在用一个文件上持有了另一个重叠的锁,那么这两个方法将抛出OverlappingFileLockException.
*在一些系统中,关闭一个通道会释放由java虚拟机持有的潜在文件上的所有锁.因此,在同一个加锁文件上应避免使用多个锁.
在网络化的文件系统上锁定文件是高度依赖于系统的,因此应该尽量避免.