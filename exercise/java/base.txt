核心机制
1 java虚拟机(体现出分层思想)
是一种与平台无关的机制 可以跨平台开发

java文件(源文件)---(java编译器)--->class文件(字节码)
--->类装载器--->字节码校验器--->解释器--->操作系统平台

源代码文件通过java编译器翻译成class(字节码)文件，再交由虚拟机运行，
虚拟机根据计算机具体平台转换成其可执行的汇编语言，从而实现了跨平台开发，一次编译，随时运行

解释器，java是解释型的语言
c/c++可以直接编译成操作系统可执行的语言，称之为编译型语言。
而java编译之后成为自己可执行的class文件，需要使用解释器。

2 垃圾回收机制
不再使用C/C++的指针
统一收集垃圾销毁

3
jdk软件开发包
jre运行环境包

4 命令
在环境变量path里面查找其所拥有的目录下是否有与该命令相同名称的.exe文件(可执行文件),有则执行,没有则报错不认识
javac:编译程序命令	javac -encoding UTF-8 -sourcepath G:\test\ -d g:\classpath XX.java
java:运行程序命令	java -Xbootclasspath/a:/usrhome/thirdlib.jar: cn.newtouch.XX
是在java的jdk路径下的bin目录下的一个javac.exe文件
classpath去找class文件
这里可以自定义一个classpath 如G:classpath之后在环境配置的CLASSPATH中添加";G:\classpath"
在java类编写的位置进行编译,之后将生成的class文件放置进制定好的classpath中,如有定义包,将class文件按照包名放置
即在G:\classpath下创建cn文件夹,在cn文件夹中再创建newtouch文件夹,之后再放置class文件

5 HolleWorld例子
参照工程java包下的HolleWorld.java
javac D:\eclipse-juno\workSpace\javaExercise\java\HolleWorld.java

6 java总结
一个java类文件中只能有一个public的class
程序的入口是main方法

执行jar命令：java -Xbootclasspath/a:/usrhome/thirdlib.jar: -jar yourJarExe.jar

jdk1.7把java.exe拷贝一份在c:\windows\system32

javap -verbose   输出堆栈大小、各方法的 locals 及 args 数,以及class文件的编译版本
javap -c         输出类中各方法的未解析的代码，即构成 Java 字节码的指令。

-----------------------------------------------------------------------------------------------------------------------
常量表类型              标志值(占1 byte)   描述
CONSTANT_Utf8                1   UTF-8编码的Unicode字符串
CONSTANT_Integer             3   int类型的字面值
CONSTANT_Float               4   float类型的字面值
CONSTANT_Long                5   long类型的字面值
CONSTANT_Double              6   double类型的字面值
CONSTANT_Class               7   对一个类或接口的符号引用
CONSTANT_String              8   String类型字面值的引用
CONSTANT_Fieldref            9   对一个字段的符号引用
CONSTANT_Methodref          10   对一个类中方法的符号引用
CONSTANT_InterfaceMethodref 11   对一个接口中方法的符号引用
CONSTANT_NameAndType        12   对一个字段或方法的部分符号引用
-----------------------------------------------------------------------------------------------------------------------
一、常量池（constantpool）->常量池的对象可以共享
常量池指的是在编译期被确定，并被保存在已编译的.class文件中的一些数据。除了包含代码中所定义的各种基本类型（如int、long等等）
和对象型（如String及数组）的常量值（final）还包含一些以文本形式出现的符号引用【例如:"123"】，比如：
1、类和接口的全限定名
2、字段的名称和描述符
3、方法和名称和描述符
虚拟机必须为每个被装载的类型维护一个常量池。同样的常量，如int值5，虽然值相同，在不同的类的常量池里都是存在的。
常量池就是该类型所用到常量的一个有序集和，包括直接常量（string,integer和floatingpoint常量）和对其他类型，字段和方法的符号引用。
对于String常量，它的值是在常量池中的。而JVM中的常量池在内存当中是以表的形式存在的，对于String类型，
有一张固定长度的CONSTANT_String_info表用来存储文字字符串值，注意：该表只存储文字字符串值，不存储符号引用。说到这里，
对常量池中的字符串值的存储位置应该有一个比较明了的理解了。在程序执行的时候，常量池会储存在方法区，而不是堆中，
并且。

常量池中String比较特殊，相同的unicode串，虽然每个类的常量池中都有一个CONSTANT_String_info条目，但是在创建这个String对象的时候
有不同的地方，每个jvm实例都维护了一个intern列表，这里存的全是String，在解析一个CONSTANT_String_info常量池条目时，
会先去intern列表中找找有没有unicode串相同的String对象，如果存在，就将intern列表中的这个对象引用放到原先的那个常量池条目中，
下一次访问时就可以直接找到对象了；如果不存在，就要创建一个String对象，并将其加到intern列表，还要放到常量池这个条目中

二、Java内存分配中的栈->栈中的对象可以共享
栈的基本单位是帧(或栈帧)：每当一个java线程运行的时候，java虚拟机会为该线程分配一个java栈。该线程在执行某个java方法的时候，
向java栈压入一个帧，这个帧用于存储参数、局部变量、操作数、中间运算结果等。当这个方法执行完的时候，帧会从栈中弹出。
Java栈上的所有数据是私有的，其他线程都不能该线程的栈数据。在函数中定义的一些基本类型的变量数据和对象的引用变量都在函数的栈内存中分配。
当在一段代码块定义一个变量时，Java就在栈中为这个变量分配内存空间，当该变量退出该作用域后，Java会自动释放掉为该变量所分配的内存空间，
该内存空间可以立即被另作他用。

*栈的优势是，存取速度比堆要快，仅次于寄存器，栈数据可以共享。但缺点是，存在栈中的数据大小与生存期必须是确定的，缺乏灵活性。
栈中主要存放一些基本类型的变量数据(int,short,long,byte,float,double,boolean,char)和对象句柄(引用)。

三、Java内存分配中的堆->堆中的对象不可以共享『所以对String对象使用"+"号是在堆中请求了新的内存填充新的数值而不是修改原数值』
java虚拟机中的堆用来存放由new创建的对象和数组。在堆中分配的内存，由Java虚拟机的自动的垃圾回收机制来管理堆的内存。和栈相对，
堆主要是用来存放java对象的，栈主要是用来存放对象地址的。在堆中产生了一个数组或对象后，栈中定义一个特殊的变量，让栈中这个变量的
值等于数组或对象在堆内存中的首地址，栈中的这个变量就成了数组或对象的引用变量。引用变量就相当于是为数组或对象起的一个名称，
以后就可以在程序中使用栈中的引用变量来访问堆中的数组或对象。引用变量就相当于是为数组或者对象起的一个名称。
引用变量是普通的变量，定义时在栈中分配，引用变量在程序运行到其作用域之外后被释放。而数组和对象本身在堆中分配，即使程序运行到
使用new产生数组或者对象的语句所在的代码块之外，数组和对象本身占据的内存不会被释放，数组和对象在没有引用变量指向它的时候，
才变为垃圾，不能再被使用，但仍然占据内存空间不放，在随后的一个不确定的时间被垃圾回收器收走(释放掉)。这也是Java比较占内存的原因。
实际上，栈中的变量就是堆内存中的变量，这就是Java中的指针！

*堆的优势是可以动态地分配内存大小，生存期也不必事先告诉编译器，因为它是在运行时动态分配内存的，Java的垃圾收集器会自动收走这些
不再使用的数据。但缺点是，由于要在运行时动态分配内存，存取速度较慢。

四、Java中的数据类型有两种
1、一种是基本类型(primitivetypes),共有8种，即int,short,long,byte,float,double,boolean,char。
这种类型的定义是通过诸如inta=3;longb=255L;的形式来定义的，称为自动变量。值得注意的是，自动变量存的是字面值，不是类的实例，
即不是类的引用，这里并没有类的存在。如inta=3;这里的a是一个指向int类型的引用，指向3这个字面值。这些字面值的数据，由于大小可知，
生存期可知(这些字面值固定定义在某个程序块里面，程序块退出后，字段值就消失了)，出于追求速度的原因，就存在于栈中。

假设我们同时定义：inta=3;intb=3；编译器先处理inta=3；首先它会在栈中创建一个变量为a的引用，然后查找有没有字面值为3的地址，
没找到，就开辟一个存放3这个字面值的地址，然后将a指向3的地址。接着处理intb=3；在创建完b的引用变量后，由于在栈中已经有3这个字面值，
便将b直接指向3的地址。这样，就出现了a与b同时均指向3的情况。特别注意的是，这种字面值的引用与类对象的引用不同。假定两个类对象的
引用同时指向一个对象，如果一个对象引用变量修改了这个对象的内部状态，那么另一个对象引用变量也即刻反映出这个变化。相反，
通过字面值的引用来修改其值，不会导致另一个指向此字面值的引用的值也跟着改变的情况。如上例，我们定义完a与b的值后，再令a=4；那么，
b不会等于4，还是等于3。在编译器内部，遇到a=4；时，它就会重新搜索栈中是否有4的字面值，如果没有，重新开辟地址存放4的值；如果已经有了，
则直接将a指向这个地址。因此a值的改变不会影响到b的值。

2、另一种是包装类数据，如Integer,String,Double等将相应的基本数据类型包装起来的类。这些类数据全部存在于堆中，Java用new()语句
来显示地告诉编译器，在运行时才根据需要动态创建，因此比较灵活，但缺点是要占用更多的时间，。

五、String是一个特殊的包装类数据
既可以用Stringstr=newString("abc");的形式来创建，也可以用Stringstr="abc"；的形式来创建【作为对比，在JDK5.0之前，
你从未见过Integeri=3;的表达式，因为类与字面值是不能通用的，除了String。而在JDK5.0中，这种表达式是可以的！
因为编译器在后台进行Integeri=newInteger(3)的转换】。

Stringstr=newString("abc")中，以下几个步骤实现：
1、在编译阶段就将"abc"写入至常量池中
2、先在栈定义一个名为str的String类的对象引用变量：Stringstr
3、在堆内存中请求一块内存，将常量池中的"abc"的值拷贝至于堆内存中，并将堆内存地址返回给str

Stringstr="abc"中，以下几个步骤实现：
1、在编译阶段就将"abc"写入至常量池中
2、定义一个名为str的对String类的对象引用变量：Stringstr
3、将常量池中的"abc"的地址返回给str
-----------------------------------------------------------------------------------------------------------------------
