2.1 什么是线程安全性
	在线程安全性的定义中，最核心的概念就是正确性。如果对象成安全性的定义是模糊的，那么就是因为缺乏对正确性的清晰定义。
	正确性的含义是，某个类的行为与其规范完全一致。在良好的规范中通常会定义各种不变性条件（Invariant）来约束对象的状态，以及定义
各种后验条件（Postcondition）来描述对象操作的结果。由于我们通常不会为类编写详细的规范，那么我们无法知道是否正确，但这并不妨碍我
们在确信“类的代码能工作”后使用它们。这种“代码可信性”非常接近于我们对正确性的理解，因此我们可以将单线程的正确性近似定义为“所见即
所知（we know it when we see it）”。在对“正确性”给出了一个较为清晰的定义后，就可以定义线程安全性：
*当多个线程访问某个类时，这个类始终都能表现出正确的行为，那么就成这个类是线程安全的。
*当多个线程访问某个类时，不管运行时环境采用何种调度方式或者这些线程将如何交替执行，并且在主调代码中不需要任何额外的同步或协同，
这个类都能表现出正确的行为，那么称这个类是线程安全的。
	如果某个类在单线程环境中都不是正确，那么它肯定不会是线程安全的。如果正确地实现了某个对象，那么在任何操作中（包括调用对象的公
有方法或者对其公有域进行读/写操作）都不会违背不变性条件或后验条件。在线程安全类的对象实例上执行的任何串行或并行操作都不会使对象处
于无效状态。
	在线程安全类中封装了必要的同步机制，因此客户端无须进一步采取同步措施。
示例：一个无状态的Servlet
	通常，线程安全性的需求并非来源于对线程的直接使用，而是使用像Servlet这样的框架。我们来看一个简单的实例---一个基于Servlet的因
数分解服务，并逐渐扩展它的功能，同时确保它的线程安全性。
	查看程序清单E2_1，与大多数Servlet相同，E2_1是无状态的：它既不包含任何域，也不包含任何对其他类中域的引用。计算过程中的临时状
态仅存在于线程栈上的局部变量中，并且只能由正在执行的线程访问。访问E2_1的线程不会影响另一个访问同一个E2_1的线程的计算结果，因为这
两个线程并没有共享状态，就好象他们都在访问不同的实例。由于线程访问无状态对象的行为并不会影响其他线程中操作的正确性，因此无状态对
象一定是线程安全的。