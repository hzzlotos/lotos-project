	要编写线程安全的代码，其核心在于要对状态访问操作进行管理，特别是对共享的（Shared）和可变的（Mutable）状态的访问。
	从非正式的意义上来说，对象的状态是指存储在状态变量（例如实例或静态域）中的数据。对象的状态可能包括其他依赖对象的域。例如，某
个HashMap的状态不仅是HashMap对象本身，还包含Map.Entry中的实例对象。在对象的状态中包含了任何可能影响其外部可见行为的数据。
	“共享”意味着变量可以由多个线程同时访问，而“可变”则意味着变量的值在其生命周期内可以发生变化。侧重于是防止在数据上发生不受控的
并发访问。
	一个对象是否需要线程安全，取决于它是否被多个线程访问。这指的是在程序中访问对象的方式，而不是对象要实现的功能。要是的对象是线
程安全的，需要采用同步机制来协同对对象可变状态的访问。如果无法实现协同，那么会导致数据破坏以及其他不该出现的结果。
	当多个线程访问某个状态变量并且其中有一个线程执行写入操作时，必须采用同步机制来协同这些线程对变量的访问。Java的主要同步机制是
关键字synchronized，它提供了一种独占的加锁方式，但“同步”这个术语还包括volatile类型的变量，显示锁（Explicit Lock）以及原子变量。
	在上述规则中并不存在一些想象中的“例外”情况。即使在某个程序中省略了必要同步机制并且看上去似乎能正确执行，而且通过了测试并在随
后几年时间里都能正确地执行，但程序仍可能在某些时刻发生错误。
	如果当多个线程访问同一可变的状态变量时没有使用合适的同步，那么程序就会出现错误。有三种方式可以修复这个问题：
*不在线程之间共享该状态变量。
*将状态变量修改为不可变的变量。
*在访问状态变量时使用同步。
	如果在设计类的时候没有考虑并发访问的情况，那么在采用上述方法时可能需要对设计进行重大修改，因此要修复这个问题是知易行难。
	在一些大型项目中，要找出多个线程在哪些位置上将访问同一个变量是非常复杂的。幸运的是，面向对象这种技术不仅有助于编写出结构优雅，
可维护性高的类，还有助于编写出线程安全的类。访问某个变量的代码越少，就越容易确保对变量的所有访问都实现正确同步，同时也更容易找出
变量在哪些条件下被访问。Java语言并没有强制要求状态都封装在类中，开发人员完全可以将状态保存在某个公开的域中，或者提供一个对内部对
象的公开引用。然而，程序状态的封装性越好，就越容易实现程序的线程安全性，并且代码的维护人员也越容易保持这种方式。
	当设计线程安全的类时，良好的面向对象技术，不可修改性，以及明晰的不变性规范都能起到一定的帮助作用。
	在某些情况中，良好的面向对象设计技术与实际情况的需求并不一致。在这些情况中，可能要牺牲一些良好的设计原则，以换取性能或者对遗
留代码的向后兼容。有时候，面向对象中的抽象和封装会降低程序的性能（尽管很少有开发人员相信），但在编写并发应用程序时，一种正确的编
程方法就是：首先使代码正确运行，然后再提供代码的速度。即便如此，最好也只能当性能测试结果和应用需求告诉你必须提高性能，以及测量结
果表明这种优化在实际环境中确实能带来性能提升时，才进行优化（在编写并发代码时，应该始终遵循这个原则。由于并发错误是非常难以重现和
调试的，因此如果只是在某段很少执行的代码路径上获得了性能提升，那么很可能被程序运行时存在的失败风险而抵消）。
	如果必须打破封装，那么也并非不可以，仍可以实现程序的线程安全性，只是更困难，而且线程的安全性将更加脆弱，不仅增加了开发的成本
和风险，而且也增加了维护的成本和风险。（第四章详细介绍了在哪些条件下可以安全的放宽状态变量的封装性）。
	线程安全的程序是否完全由线程安全类构成？答案是否定的，完全由线程安全类构成的程序并不一定就是线程安全的，而在线程安全类中也可
以包含非线程安全的类（第四章还将进一步介绍如何对线程安全类进行组合的相关问题）。在任何情况中，只有当类中仅包含自己的状态时，线程
安全类才是有意义的。线程安全性是一个在代码上使用的术语，但它只是与状态相关的，因此只能应用于封装其状态的整个代码，这可能是一个对
象，也可能是整个程序。