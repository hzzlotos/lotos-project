2.2 原子性
	当我们在无状态对象中增加一个状态时，会出现什么情况？假设我们希望增加一个“命中计数器”（Hit Counter）来统计所处理的请求数量。
一种直观的方法是在Servlet中增加一个long类型的域，并且每处理一个请求将这个值+1，如程序清单E2_2中的程序所示。
	不幸的是E2_2并非线程安全的，尽管它在单线程环境中能正确运行。与前面的E1_1一样，这个类很可能会丢失一些更新操作。虽然递增操作
++count是一种紧凑的语法，使其看上去只是一个操作，但这个操作并非原子的，因而它并不会作为一个不可分割的操作来执行。实际上，它包含
了三个独立的操作：读取count的值，将值+1，然后将计算结果写入count。这是一个“读取-修改-写入”的操作序列，并且其结果状态依赖于之前的
状态。
	在之前的图1_1.png中给出了两个线程在没有同步的情况下同时对一个计数器执行递增操作时发生的情况。如果计数器的初始值为9，那么在某
些情况下，每个线程读到的值都为9，接着执行递增操作，并且都将计数器的值设为10。显然这并不是我们希望看到的情况，如果有一次递增操作
丢失了，命中计数器的值就将偏差1。这将会导致严重的数据完整性问题。
【在并发编程中，这种由于不恰当的执行时序而出现不正确的结果是一种非常重要的情况，它有一个正式的名字：竞态条件（Race Condition）】

2.2.1 竞态条件
	在E2_2中存在多个竞态条件，从而使结果变得不可靠。当某个计算的正确性取决于多个线程的交替执行时序时，那么就会发生竞态条件。换句
话说就是正确的结果要取决于运气。『竞态条件这个术语很容易与另一个相关术语』
最常见的竞态条件类型就是“先检查后执行（Check-Then-Act）”操作，即通过一个可能失效的观测结果来决定下一步的动作。
	在实际情况中经常会遇到竞态条件。例如，假定你计划中午在大学路的星巴克与一位朋友会面。但当你到达那里时，发现在大学路上有两家星
巴克，并且你不知道说好碰面的是哪一家。在12:10时，你没有在星巴克A看到朋友，那么就会去星巴克B看看他是否在那里，但他也不在那里。这
有几种可能：1.你的朋友迟到了，还没有到任何一家星巴克；2.你的朋友在你离开后到了星巴克A；3.你的朋友在星巴克B，但他去星巴克A找你，
并且此时正在去星巴克A的途中。我们假设是最糟糕的情况，即最后一种可能。现在是12:15，你们两个都去过了两家星巴克，并且都开始怀疑对方
是否失约了。现在该怎么做？到另一家星巴克？来来回回要走多少次？除非你们之间约定了某种协议，否则整天都在大学路上走来走去，倍感沮丧。
	在“我去看看他是否在另一家星巴克”这种方法中，问题在于：当你在街上走时，你的朋友可能已经离开了你要去的星巴克。你首先看了看星巴
克A，发现“他不在”，并且开始去找他。你可以在星巴克B中做同样的选择，但不是同时发生。两家星巴克之间有几分钟的路程，而就在这几分钟的
时间里，系统的状态可能会发生变化。
	在星巴克这个实例中说明了一种竞态条件，因为要获得正确的结果（与朋友会面），必须取决于事件的发生时序（当你们到达星巴克时，在离
开并去另一家星巴克之前会等待多长时间...）。当你迈出前门时，你在星巴克A的观察结果将变得无效，你的朋友可能从后面进来了，而你却不知
道。这种观察结果的失效就是大多数竞态条件的本质---基于一种可能失效的观察结果来做出判断或者执行某个计算。这种类型的竞态条件称为“先
检查后执行”：首先观察到某个条件为真（例如文件X不存在），然后根据这个观察结果采用相应的动作（创建文件X），但事实上，在你观察到这个
结果以及开始创建文件之间，观察结果可能变得无效（另一个线程在这个期间创建了文件X），从而导致各种问题（未预期的异常，数据被覆盖，文
件被破坏等）。

2.2.2 示例：延迟初始化的中竞态条件
	使用“先检查后执行”的一种常见情况就是延迟初始化。延迟初始化的目的是将对象的初始化操作推迟到实际被使用时才进行，同时要确保只被
初始化一次。在程序清单2-3中说明了这种延迟初始化情况。getInstance方法首先判断ExpensiveObject是否已经被初始化，如果已经初始化则返
回现有的实例，否则将创建一个新的实例，并返回一个引用，从而在后来的调用中就无须再执行这段高开销的代码路径。






	