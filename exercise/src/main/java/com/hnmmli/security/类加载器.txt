9.1 类加载器
java编译器会为虚拟机转换源指令.虚拟机代码存储在以.class为扩展名的类文件中.每个类文件都包含某个类或者接口的定义和代码实现.
这些类文件必须由一个解释器进行解释,该解释器能够将虚拟机的指令集翻译成目标机器的机器语言.!!注意!! 虚拟机只加载程序执行时所需类
文件.
例->程序从myProgram.class开始运行,下面是虚拟机执行步骤:
1)虚拟机有一个用于加载类文件的机制,例如从磁盘上读取文件或者请求web上的文件;使用该机制来加载myProgram类文件中的内容
2)如果MyProgram类拥有类型为另一个类的实例变量,或者是拥有超类,那么这些类文件也会被加载.(加载某个类所依赖的所有类的过程称为类的解析)
3)接着,虚拟机执行myprogram中的main方法(它是静态的,无需创建类的实例)
4)如果main方法或者main调用的方法要用到更多的类,那么接下来就会加载这些类.然而,类加载机制并非只使用单个的类加载器.
	每个java程序至少拥有三个类加载器
		(1)引导类加载器: 负责加载系统类(通常从JAR文件rt.jar中进行加载).它是虚拟机整体中的一部分,而且通常是用C语言来实现的.
		引导类加载器没有对应的ClassLoader对象,例如,String.class.getClassLoader()将返回null.
		(2)扩展类加载器: 用于从jre/lib/ext目录加载"标准的扩展".可以将jar文件放入该目录,这样即使没有任何类路径,扩展类加载器也
		可以找到其中的各个类.(有人推荐使用该机制来避免"万恶的类路径",不过要注意警告事项)
		(3)系统类加载器(有时也称为应用类加载器): 用于加载应用类.它在由classpath环境变量或者-classpath命令行选项设置的类路径中
		的目录里或者是jar/zip文件里查找这些类.
	在sun公司的java语言实现中,扩展类加载器和系统类加载器都是用java来实现的.他们都是URLClassLoader类的实例.
9.1.1 类加载器的层次结构
	类加载器有一种父/子关系.除了引导类加载器外,每个类加载器都有一个父类加载器.根据规定,类加载器会为它的类加载器提供一个机会,以
便加载任何给定的类,并且只有在其父类加载器加载失败时,它才会加载该给定类.例如,当要求系统类加载器加载一个系统类
(例如java.util.ArrayList)时,它首先要求扩展类加载器进行加载,该扩展类加载器则首先要求引导类加载器进行加载.引导类加载器查找并加载
rt.jar中的这个类,而无须其他类加载器做更多的搜索.
	某些程序程序具有插件架构,其中代码的某些部分是作为可选的插件打包的.如果插件被打包为jar文件,那就可以直接用URLClassLoader类的
实例去加载这些类.因为在URLClassLoader构造器中指定父类加载器,即系统类类加载器.
	干涉与指定类加载器: 应用代码包含一个助手方法,需要调用Class.forName(classNameString).这个方法是从一个插件类中被调用的.而
classNameString指定的正是一个包含在这个插件的jar中的类.












