1.1 并发简史
	之所以在计算机中加入操作系统来实现多程序同时执行，主要是基于以下原因：
*资源利用率。在等待同时运行另一个程序，大大提高了资源利用率。
*公平性。不同用户和程序对计算机上的资源有着同等的使用权。
*便利性。通常来说在计算多个任务时，应编写多个程序，每个程序执行一个任务并在必要时相互通讯，这比只编写一个程序来计算所有任务更容易
实现。
	串行编程模型的优势在于其直观性与简单性。每次只做一件事情，做完之后再做另一件。但早上起来烧水，烤面包，看报纸可以一起进行，因
为茶壶和面包机的生产商都很清楚用户通常会采用异步方式来使用他们的产品，因此这些机器在完成之后都会发出提示音。
	线程允许在同一个进程中同时存在多个程序控制流。线程会共享进程范围内的资源，但每个线程都有各自的程序计数器，栈，以及局部变量等。
线程还提供了一种直观的分解模式来充分利用多处理器系统中的硬件并行性，而在同一个程序中多个线程也可以被同时调度到多个CPU上运行。线程
还提供了一种直观的分解模式来充分利用多处理器系统中的硬件并行性，而在同一个程序中的多个线程也可以被同时调度到多个CPU上运行。
	如果没有明确的协同机制，那么线程将彼此独立的执行。由于同一个进程中的所有线程都将共享进程的内存地址空间，因此这些线程都能访问
相同的变量并在同一个堆上分配对象，这需要实现一种比在进程间共享数据粒度更细的数据共享机制。如果没有明确的同步机制来协同对共享数据
的访问，那么当一个线程正在使用某个变量时，另一个线程可能同时访问这个变量，这将造成不可预测的结果。

1.2 线程的优势
	如果使用得到，线程可以有效的降低程序的开发和维护成本，同时提升复杂应用程序的性能。线程能够将大部分的异步工作流转换成串行工作
流，因此能更好的模拟人类的工作方式和交互方式。此外线程还可以降低代码的复杂度，是代码更容易编写，阅读和维护。

1.2.1 发挥多处理器的强大能力
	由于基本的调度单位是线程，因此如果在程序中只有一个线程，那么最多同时只能在一个处理器上运行。在双处理器系统上，单线程的程序只
能使用一半的CPU资源；另一方面，多线程程序可以同时在多个处理器上执行。如果设计正确，多线程程序可以通过提高处理器资源的利用率来提升
系统吞吐率。使用多线程也有助于在单处理器系统上获得更好吞吐率。

1.2.2 建模的简单性
	只需要执行一种类型的任务，在时间管理方面比执行多种类型的任务要简单。如果需要完成多种类型的任务，那么管理不同任务间的优先级和
执行时间，并且在任务之间进行切换，这将带来额外的开销。
	对于程序来说也是如此：如果程序中只包含一种类型的任务，那么比包含多种不同类型任务的程序要易于编写，错误更少，也更容易测试。如
果为模型中每种类型的任务都分配一个专门的线程，那么可以形成一种串行执行的假象，并将程序的执行逻辑与调度机制的细节。交易执行的操作。
异步I/O以及资源等待问题分离开来。通过使用线程，可以将复杂并且异步的工作流进一步分解为一组简单并且同步的工作流，每个工作流在一个
单独的线程中运行，并在特定的同步位置进行交互。
	我们可以通过一些现有的框架来实现上述目标，例如Servlet与RMI。框架负责一些细节问题，例如请求管理，线程创建，负载均衡，并在正确
的时刻将请求分发给正确的应用程序组件。编写Servlet的开发人员不需要了解有多少请求在同一时刻要被处理，也不需要了解套接字的输入流或
输出流是否被阻塞。当调用Servlet的service方法来响应Web请求时，可以以同步方式来处理这个请求，就好象它是一个单线程程序。这种方式可
以简化组件的开发，并缩短掌握这种框架的学习时间。

1.2.3 异步事件的简化处理
	服务器应用程序在接受来自多个远程客户端的套接字连接请求时，如果为每个连接都分配其各自的线程并且使用同步I/O，那么就会降低这类
程序的开发难度。
	如果某个应用程序对套接字执行读操作而此时还有数据到来，那么这个读操作将一直阻塞，直到有数据到达。在单线程应用程序中，这不仅意
味着在处理请求的过程中将停顿，热切还意味着这个线程被阻塞期间，对所有请求的处理都将停顿。为了避免这个问题，单线程服务器应用程序必
须使用非阻塞I/O，这种I/O的复杂性要远远高于同步I/O，并且很容易出错。然而如果每个请求都拥有自己的处理线程，那么在处理某个请求发生
的阻塞将不会影响其他请求的处理。
	早期的操作系统通常会将进程中可创建的线程数量限制在一个较低的阀值内，大约在数百个（甚至更少）左右。因此操作系统提供了一些高效
的方法来实现多路I/O，Java类库提供了一组非阻塞I/O的包（java.nio）。

1.2.4 响应更灵敏的用户界面

1.3 线程带来的风险
	Java对于线程的支持其实是一把双刃剑。
	
1.3.1 安全性问题
	线程安全性可能是非常复杂的，在没有充足同步的情况下，多个线程中的操作执行顺序哦是不可预测的，甚至会产生奇怪的结果。在程序E1_1
类中产生一个整数值序列，该序列中的每个值都是唯一的。在单线程环境中，这个类能正确的工作，但多线程下则不能。多线程之间的交替操作将
导致不可预料的结果。
	问题在于，如果执行时机不对，那么两个线程在调用getNext时会得到相同的值。在图1_1中给出了这种错误情况。虽然递增运算++看上去是个
单个操作，但实际上它包含三个独立的操作：读取value，将value+1，并将计算结果写入value。由于运行时可能将多个线程间的操作交替执行，
因此这两个线程可能同时执行读操作，从而使得他们得到相同的值，并将该值+1。结果就是在不同的线程调用中返回了相同的数值。
	在E1_1类中出现的问题是一种常见的并发安全问题，称之为【竞态条件（Race Condition）】。在多线程环境下，getValue是否会返回唯一
的值，要取决于运行时对线程中操作的交替执行方式，这并不是我们希望看到的情况。
	由于多个线程要共享相同的内存地址空间，并且是并发运行，因此他们可能会访问或修改其他线程正在使用的变量。虽然带来了极大的便利，
因为这种方式比其他线程间通讯机制更容易实现数据共享。而同样也带来了巨大的风险：线程会由于无法预料的数据变化而发生错误。当多个线程
同时访问和修改相同的变量时，将会在串行编程模型中引入非串行因素，而这种非串行性是很难分析的。要使更多线程程序的行为可以预测，必须
对共享变量的访问操作进行协同，这样才不会在线程之间发生彼此干扰。通过将getnext修改为一个同步方法，可以修改E1_1中的错误，如程序清
单E1_2，可以防止E1_1中错误的交替执行情况。
	如果没有同步，那么无论是编译器，硬件还是运行时，都可以随意安排操作的执行时间和顺序，例如对寄存器或者处理器中的变量进行缓存，
而这些被缓存的变量对于其他线程来说是暂时（甚至永久）不可见的。虽然这些技术有助于实现更优的性能，并且通常也是值得采用的方法，但他
们也为开发人员带来了负担，因为开发人员必须找出这些数据在哪些位置被多个线程共享，只有这样才能使这些优化措施不破坏线程安全性。

1.3.2 活跃性问题
	在开发并发代码时，一定要注意线程安全性是不可破坏的。安全性不仅对多线程序很重要，对于单线程程序同样重要。此外，线程还会导致一
些在单线程程序中不会出现的问题，例如活跃性问题。安全性的含义是“永远不发生糟糕的事情”，而活跃性则关注另一个目标，即“某件正确的事
情最终会发生”。当某个操作无法继续执行下去时，就会发生活跃性问题。在串行程序中，活跃性问题的形式之一就是无意中造成的无限循环，从而
使循环之后的代码无法得到执行。线程将带来其他一些活跃性问题。例如，如果线程A在等待线程B释放其持有的资源，而线程B永远都不释放该资源，
那么A就会永久地等待下去（如死锁10.1节，饥饿10.3.1节，以及活锁10.3.3）。与大多数并发错误一样，导致活跃性问题的错误同样是难以分析
的。因为他们依赖于不同线程的时间发生时序，因此开发或测试中并不总能够重现。

1.3.3 性能问题
	与活跃性问题密切相关的是性能问题。活跃性意味着某件正确的事情最终会发生，但通常会希望事情尽快发生。性能问题包括多个方面，例如，
服务时间过长，响应不灵敏，吞吐率过低，资源消耗过高，或者可伸缩性较低等。与安全性和活跃性一样， 在多线程程序中不仅存在与单线程程序
相同的性能问题，而且还存在由于使用线程而引入的其他性能问题。
	在设计良好的并发应用程序中，线程能提升程序的性能，但无论如何，线程总会带来某种程度的运行时开销。在多线程程序中，当线程调度器
临时挂起活跃线程并转而运行另一个线程时，就会频繁地出现上下文切换操作，这种操作将带来极大的开销：保存和恢复执行上下文，丢失局部性，
并且CPU时间将更多花在线程调度而不是线程运行上。当线程共享数据时，必须使用同步机制，而这些机制往往会抑制某些编译器优化，是内存缓存
区中的数据无效，以及增加共享内存总线的同步流量。所有这些因素都将带来额外的性能开销。

1.4 线程无处不在
	即使在程序中没有显式地创建线程，但在框架中仍可能会创建线程，因此在这些线程中调用的代码同样必须是线程安全的。这将给开发人员在
设计和实现上带来沉重负担，因为开发线程安全的类比开发非线程安全的类要更加谨慎和细致。
	每个Java应用程序都会使用线程。当JVM启动时，它将为JVM的内部任务创建后台线程，并创建一个主线程来运行main方法。AWT和Swing的用
户界面框架将创建线程来管理用户界面事件。Timer将创建线程来执行延迟任务。一些组件框架，如Servlet和RMI，都会创建线程池并调用这些线
程中的方法。
	现实情况是几乎所有Java应用程序都是多线程的，因此在使用这些框架时仍需对应用程序状态的访问进行协同。当某个框架在应用程序中引入
并发性时，通常不可能将并发性仅局限于框架代码，因为框架本身会回调（Callback）应用程序的代码，而这些代码将访问应用程序的状态。同样，
对线程安全性的需求也不能局限于被调用的代码，而是要延伸到需要访问这些代码所访问的程序状态的所有代码路径。因此对线程安全性的需求将
在程序中蔓延开来。
1.Timer：Timer类的作用是使任务在稍后的时刻运行，或者运行一次或者周期性的运行。引入Timer可能会使串行程序变得复杂，因为TimerTask
将在Timer管理的线程中执行,而不是由应用程序来管理。如果某个TimerTask访问了应用程序中其他线访问的数据，那么不仅TimerTask需要以线
程安全的方式来访问数据，其他类也必须采用线程安全的方式来访问该数据。通常需要实现这个目标，最简单的方式是确保TimerTask访问的对象
本身是线程安全的，从而就能把线程安全性封装在共享对象内部。
2.Servlet与JavaServer Page（Jsp）：Servlet框架用于部署网页应用程序以及分发来自HTTP客户端的请求。到达服务器的请求可能会通过一
个过滤器链被分发到正确的Servlet或JSP。每个Servlet都表示一个程序逻辑组件，在高吞吐率的网站中，多个客户端可能同时请求用一个Servlet
的服务。在Servlet规范中，Servlet同样需要满足被多个线程同时调用，换句话说Servlet需是要线程安全的。
	即使你确保每次只有一个线程调用某个Servlet，但在构建网页应用程序时仍然必须注意线程安全性。Servlet通常会访问与其他Servlet共享
的信息，例如应用程序中的对象（这些对象保存在ServletContext中）或者会话中的对象（这些对象保存在每个客户端的HttpSession中）。当一
个Servlet访问在多个Servlet或者请求中共享的对象时，必须正确地协同对这些对象的访问，因为多个请求可能在不同的线程中同时访问这些对象。
Servlet和JSP以及在ServletContext和HttpSession等容器中保存的Servlet过滤器和对象等，都必须是线程安全的。
3.远程方法调用（RMI）：RMI使代码能够调用在其他JVM中运行的对象。当通过RMI调用某个远程方法时，传递给方法的参数必须被打包（也称为
列集[Marshaled]）到一个字节流中，通过网络传输给远程JVM，然后由远程JVM拆包（或者成为散集[Unmarshaled]）并传递给远程方法。
	当RMI代码调用远程对象时，这个调用将在哪个线程中执行。你并不知道，但肯定不会在你创建的线程中，而是将在一个由RMI管理的线程中调
用对象。RMI会创建多少个线程？同一个远程对象上的同一个远程方法会不会在多个RMI线程中被同时调用？
	远程对象必须注意两个线程安全性问题：正确地协同在多个对象中共享的状态，以及对远程对象本身状态的访问（由于同一个对象可能会在多
个线程中被同时访问）。与Servlet相同，RMI对象应该做好被多个线程同时调用的准备，并且必须确保他们自身的线程安全性。







