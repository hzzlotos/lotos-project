	要编写线程安全的代码，其核心在于要对状态访问操作进行管理，特别是对共享的（Shared）和可变的（Mutable）状态的访问。
	从非正式的意义上来说，对象的状态是指存储在状态变量（例如实例或静态域）中的数据。对象的状态可能包括其他依赖对象的域。例如，某
个HashMap的状态不仅是HashMap对象本身，还包含Map.Entry中的实例对象。在对象的状态中包含了任何可能影响其外部可见行为的数据。
	“共享”意味着变量可以由多个线程同时访问，而“可变”则意味着变量的值在其生命周期内可以发生变化。侧重于是防止在数据上发生不受控的
并发访问。
	一个对象是否需要线程安全，取决于它是否被多个线程访问。这指的是在程序中访问对象的方式，而不是对象要实现的功能。要是的对象是线
程安全的，需要采用同步机制来协同对对象可变状态的访问。如果无法实现协同，那么会导致数据破坏以及其他不该出现的结果。
	当多个线程访问某个状态变量并且其中有一个线程执行写入操作时，必须采用同步机制来协同这些线程对变量的访问。Java的主要同步机制是
关键字synchronized，它提供了一种独占的加锁方式，但“同步”这个术语还包括volatile类型的变量，显示锁（Explicit Lock）以及原子变量。
	在上述规则中并不存在一些想象中的“例外”情况。即使在某个程序中省略了必要同步机制并且看上去似乎能正确执行，而且通过了测试并在随
后几年时间里都能正确地执行，但程序仍可能在某些时刻发生错误。
	如果当多个线程访问同一可变的状态变量时没有使用合适的同步，那么程序就会出现错误。有三种方式可以修复这个问题：
*不再线程之间共享该状态变量。
*将状态变量修改为不可变的变量。
*在访问状态变量时使用同步。
	如果在设计类的时候没有考虑并发访问的情况，那么在采用上述方法时可能需要对设计进行重大修改，因此要修复这个问题是知易行难。
	在一些大型项目中，要找出多个线程在哪些位置上将访问同一个变量是非常复杂的。幸运的是，面向对象这种技术不仅有助于编写出结构优雅，
可维护性高的类，还有助于编写出线程安全的类。访问某个变量的代码越少，就越容易确保对变量的所有访问都实现正确同步，同时也更容易找出
变量在哪些条件下被访问。Java语言并没有强制要求状态都封装在类中，开发人员完全可以将状态保存在某个公开的域中，或者提供一个对内部对
象的公开引用。然而，程序状态的封装性越好，









