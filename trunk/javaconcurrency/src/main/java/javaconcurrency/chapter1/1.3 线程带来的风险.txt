1.3 线程带来的风险
	Java对于线程的支持其实是一把双刃剑。

1.3.1 安全性问题
	线程安全性可能是非常复杂的，在没有充足同步的情况下，多个线程中的操作执行顺序哦是不可预测的，甚至会产生奇怪的结果。在程序E1_1
类中产生一个整数值序列，该序列中的每个值都是唯一的。在单线程环境中，这个类能正确的工作，但多线程下则不能。多线程之间的交替操作将
导致不可预料的结果。
	问题在于，如果执行时机不对，那么两个线程在调用getNext时会得到相同的值。在图1_1中给出了这种错误情况。虽然递增运算++看上去是个
单个操作，但实际上它包含三个独立的操作：读取value，将value+1，并将计算结果写入value。由于运行时可能将多个线程间的操作交替执行，
因此这两个线程可能同时执行读操作，从而使得他们得到相同的值，并将该值+1。结果就是在不同的线程调用中返回了相同的数值。
	在E1_1类中出现的问题是一种常见的并发安全问题，称之为【竞态条件（Race Condition）】。在多线程环境下，getValue是否会返回唯一
的值，要取决于运行时对线程中操作的交替执行方式，这并不是我们希望看到的情况。
	由于多个线程要共享相同的内存地址空间，并且是并发运行，因此他们可能会访问或修改其他线程正在使用的变量。虽然带来了极大的便利，
因为这种方式比其他线程间通讯机制更容易实现数据共享。而同样也带来了巨大的风险：线程会由于无法预料的数据变化而发生错误。当多个线程
同时访问和修改相同的变量时，将会在串行编程模型中引入非串行因素，而这种非串行性是很难分析的。要使更多线程程序的行为可以预测，必须
对共享变量的访问操作进行协同，这样才不会在线程之间发生彼此干扰。通过将getnext修改为一个同步方法，可以修改E1_1中的错误，如程序清
单E1_2，可以防止E1_1中错误的交替执行情况。
	如果没有同步，那么无论是编译器，硬件还是运行时，都可以随意安排操作的执行时间和顺序，例如对寄存器或者处理器中的变量进行缓存，
而这些被缓存的变量对于其他线程来说是暂时（甚至永久）不可见的。虽然这些技术有助于实现更优的性能，并且通常也是值得采用的方法，但他
们也为开发人员带来了负担，因为开发人员必须找出这些数据在哪些位置被多个线程共享，只有这样才能使这些优化措施不破坏线程安全性。

1.3.2 活跃性问题
	在开发并发代码时，一定要注意线程安全性是不可破坏的。安全性不仅对多线程序很重要，对于单线程程序同样重要。此外，线程还会导致一
些在单线程程序中不会出现的问题，例如活跃性问题。安全性的含义是“永远不发生糟糕的事情”，而活跃性则关注另一个目标，即“某件正确的事
情最终会发生”。当某个操作无法继续执行下去时，就会发生活跃性问题。在串行程序中，活跃性问题的形式之一就是无意中造成的无限循环，从而
使循环之后的代码无法得到执行。线程将带来其他一些活跃性问题。例如，如果线程A在等待线程B释放其持有的资源，而线程B永远都不释放该资源，
那么A就会永久地等待下去（如死锁10.1节，饥饿10.3.1节，以及活锁10.3.3）。与大多数并发错误一样，导致活跃性问题的错误同样是难以分析
的。因为他们依赖于不同线程的时间发生时序，因此开发或测试中并不总能够重现。

1.3.3 性能问题
	与活跃性问题密切相关的是性能问题。活跃性意味着某件正确的事情最终会发生，但通常会希望事情尽快发生。性能问题包括多个方面，例如，
服务时间过长，响应不灵敏，吞吐率过低，资源消耗过高，或者可伸缩性较低等。与安全性和活跃性一样， 在多线程程序中不仅存在与单线程程序
相同的性能问题，而且还存在由于使用线程而引入的其他性能问题。
	在设计良好的并发应用程序中，线程能提升程序的性能，但无论如何，线程总会带来某种程度的运行时开销。在多线程程序中，当线程调度器
临时挂起活跃线程并转而运行另一个线程时，就会频繁地出现上下文切换操作，这种操作将带来极大的开销：保存和恢复执行上下文，丢失局部性，
并且CPU时间将更多花在线程调度而不是线程运行上。当线程共享数据时，必须使用同步机制，而这些机制往往会抑制某些编译器优化，是内存缓存
区中的数据无效，以及增加共享内存总线的同步流量。所有这些因素都将带来额外的性能开销。